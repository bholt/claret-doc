# Background

There are many popular news stories about different services like BuzzFeed [@buzzfeed-dress] and Instagram [@bieber-instagram] and their struggles with unpredictable Internet traffic.
Before launching into the programming model and implementation, we will motivate 
the difficulties with implementing web services by delving more deeply into one example — a ticket sales service — which we will use throughout the rest of the paper.

In October 2015, movie ticket pre-sales became available for the much-anticipated new movie in the Star Wars franchise. The demand for these tickets was so high that many movie ticket sites, including big players such as AMC and Fandango, saw catastrophic performance drops; some smaller vendors even had crashes which resulted in loss of purchases and significant media backlash [@forbes:star-wars]. Missing the opening night of a movie may not be the most dire of circumstances, but it illustrates that web services must be prepared for all kinds of situations, even if they only happen in the smallest minority of instances.

~ Fig { #fig-tickets caption="Ticket sales service with performance and correctness requirements." }
![](fig/tickets.pdf)
~

Let's look at how we would model this application using existing datastore options. [#fig-tickets] shows a high-level schematic of a ticket sales application. Each event (in this case movie, location, and time) has some number of available tickets. Very large events such as big conventions or conferences are likely to cause even more problems than movie showings if tickets are likely to sell out quickly. Visitors to the site may browse the events, and *view* individual events to see how many tickets are remaining. Finally, they can *purchase* some tickets.

The most important invariant is that tickets are not over-sold: each available ticket must only go to one user. However, there are other, softer, constraints for this application:

1. Users browsing many events will become frustrated if pages take too long to load, so there is an implicit latency target.
2. Users want to know how many tickets are remaining to determine how quickly they need to purchase them.

If the latency target is not met, users may choose to take their business to other sites. Similarly, if the remaining ticket count is off, such as if the count is stale and there are in fact fewer remaining tickets, then users may not get the tickets they wanted. Some amount of inaccuracy in the count is unavoidable; there is an absolute bound on the round trip time, for instance, but we may hope to keep this count as up-to-date as possible.

Using existing systems, we have few options for meeting these requirements. In order to ensure that the ticket count does not go negative, we need linearizability [@Herlihy:90:Linear;@Sivaramakrishnan:15:Quelea]. In Cassandra, we cannot do this with the `Counter` datatype but could with their "lightweight transactions" on a normal record, but this makes reads of the count prohibitively slow. We could use a second, weakly consistent counter, to approximate the remaining ticket count; this could be arbitrarily off and could drift if we do not synchronize periodically with the true value. Overall, it introduces significant implementation complexity. A convergent replicated data type (CRDT) [@Shapiro:SSS11:CRDT] called a `BoundedCounter` [@Balegas:15:BoundedCounter] can enforce the invariant we want even on eventual consistency, which gives good performance and safety, but does not give us any bound on how accurate the count is at any time. What we need is a *datatype* that encodes the hard lower-bound and the soft error bound, which we will in [#sec-adts] and [#sec-ipa-types].

Ensuring low-latency browsing is also difficult. If we blindly use weak consistency, then users could occasionally miss new events (especially relevant to anyone refreshing waiting for Star Wars tickets), or see events that should have been deleted. Internally, we must now handle new potential inconsistencies, such as late actions on deleted events.
During low-traffic times, these inconsistencies may be unnecessary. If we know the load is low, we should try to use stronger consistency to retrieve the results, and in times of heavy load, we could indicate to the user that the results may be inaccurate.
