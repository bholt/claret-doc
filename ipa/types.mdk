# Type System

<!-- Developers of distributed applications 
today manually manage the consistency--performance trade-off.
Managing these trade-offs is error-prone 
because they require changing the consistency model 
at the granularity of individual operations.
The reliability of the resulting applications is also unclear,
because local changes in the consistency model may propagate to other operations,
and testing against every possible relaxation is difficult. -->

We propose a programming model for distributed data 
that uses types to control the consistency--performance trade-off.
The *inconsistent, performance-bound, approximate* (IPA) type system
helps developers trade consistency for performance in a disciplined manner.
This section presents the IPA type system, 
including the available consistency policies
and the semantics of operations performed under those policies.
[#sec-implementation] will explain how the type system's guarantees are enforced for a distributed datastore.

## Overview

The IPA type system consists of three parts:

* Abstract data types (ADTs) implement common distributed data structures (such as `Set[T]`).
* Policy annotations on ADTs specify the desired consistency level for an object in application-specific terms (such as latency or accuracy bounds).
* IPA types track the consistency of operation results and enforce consistency safety by requiring developers to consider weak outcomes.

Together, these three components provide two key benefits for developers.
First, the IPA type system enforces *consistency safety*, tracking the consistency level of each result and preventing inconsistent data from flowing into consistent data without explicit endorsement, in the style of EnerJ ([@TODO]).
Second, the IPA type system provides *performance*, because consistency annotations at the ADT level allow the runtime to dynamically select the consistency for each individual operation that maximizes performance in a constantly changing environment.

## Abstract Data Types

The base of the IPA type system is a set of abstract data types (ADTs) for common distributed data structures. Though the simplest key/value stores only support primitive types like strings for values, many popular datastores now have built-in support for more complex data structures such as sets, lists, maps, and other specialized types. However, each datastore has its own interface to these types: Redis's [@redis] types are implicit in the command used to operate on them, Cassandra [@Lakshman:10:Cassandra] uses a more relational-style model with tables and columns and composite keys, while Riak [@riak] and Hyperdex [@hyperdex-web;@hyperdex] support more direct data structure access. Our library of ADTs allows us to decouple our type system from any particular datastore, though our reference implementation is on top of Cassandra, similar to [@Sivaramakrishnan:15:Quelea].

Besides abstracting over various storage systems, ADTs are an ideal place from which to begin reasoning about consistency and system-level optimizations. ADTs present a clear abstract model through a set of operations which query and update the state, allowing users and systems alike to reason about their logical, algebraic properties rather than the low-level operations used to implement them. Moreover, as we will see in the coming sections, annotating datatypes, rather than individual operations, is crucial because ADTs are where writes and reads meet and affect one another.


## Policy Annotations { #policies }

The IPA type system provides
a set of annotations that can be placed on ADT instances
to specify consistency policies.
Previous systems [@cassandra;@riak;@Terry:13:SLAs;@Li:12:RedBlue;@Sovran:11:Walter] require annotating each read and write operation with a desired consistency level.
This per-operation approach complicates reasoning about the safety of code using weak consistency,
and hinders global optimizations that can be applied if the system knows the consistency level required for future operations.

IPA type annotations come in two flavors.
*Static* annotations declare an explicit consistency policy for an ADT.
For example, a `Set` ADT with elements of type `T` can be declared as `Set[T] with Consistency(Strong)`,
which states that all operations on that object are performed with strong consistency.
Static annotations provide the same direct control as existing approaches, 
but simplify reasoning about correctness.
*Dynamic* annotations specify a consistency policy in terms of application-level requirements.
For example, a `Set` ADT can be declared as `Set[T] with LatencyBound(50 ms)`,
which states that operations on that object are performed with a target latency bound in mind. The runtime is free to dynamically choose, on a per-operation basis, whichever consistency level is necessary to meet this bound.

The IPA type system features two dynamic consistency policies:

* A latency policy `LatencyBound(x ms)` specifies a target latency for each operation performed on the ADT. The runtime can then determine the consistency level for each individual operation issued, optimizing for the cheapest level that will likely satisfy the latency bound.
* An accuracy policy `ErrorTolerance(x%)` specifies the desired accuracy for read operations performed on the ADT. For example, the `size` of a `Set` ADT may only need to be accurate within 5% tolerance. The runtime can optimize the consistency of write operations so that reads are guaranteed to meet this bound.

Policy annotations are central to the flexibility and usability of the IPA type system.
Dynamic policy annotations allow the runtime 
to extract the maximum performance possible from an application 
by relaxing the consistency of its operations, 
safe in the knowledge that the IPA type system has enforced safety
by requiring the developer to consider the effects of weak operations.
Moreover, policy annotations are expressed in terms of application-level requirements, such as latency or accuracy.
This higher-level semantics absolves developers of manipulating the consistency of individual operations to maximize performance while maintaining safety.

As an extension, ADTs can also have different consistency policies for each method.
For example, a `Set` ADT might have a relaxed consistency policy for its `size`,
but a strong consistency policy for its `contains?` predicate method.
The runtime is then responsible for managing the interaction between these consistency policies. In the case of a conflict between two bounds, the system can be conservative and choose stronger policies than specified without affecting correctness.

## IPA Types

The keys to the IPA type system are the IPA types themselves.
Read operations of ADTs annotated with consistency policies return instances of an *IPA type*.
These IPA types track the consistency of the results,
and enforce a fundamental non-interference property: 
results from weakly consistent operations cannot flow into computations with stronger consistency without explicit endorsement.

Formally, the IPA types form a lattice parameterized by a primitive type `T`. 
The bottom element `Inconsistent[T]` specifies an object with the weakest possible consistency. 
The top element is `Consistent[T]`, an object with the strongest possible consistency, which has an implicit cast to type `T` available.
The other IPA types follow a subtyping relation $\prec$, defined by:

~ Math
\inferrule{\tau \text{ is weaker than } \tau'}{\tau'[T] \prec \tau[T]}
~

The IPA type system is very similar to the probability type system of DECAF [@TODO], which uses types to track the quality of results computed on approximate hardware. Their non-interference property is also similar: a result of low quality cannot flow into a result of higher quality without explicit endorsement.
We elide a thorough formal development of the IPA type system due to its close similarity with DECAF.

### Weak IPA types

The IPA types encapsulate information about the consistency policy used to perform a read operation.
Strong read operations return values of type `Consistent[T]`,
and so (by implicit casting) appear to developers as any other instance of type `T`.
Intuitively, this equivalence is because the results of strong reads are known to be consistent, which corresponds to the control flow in conventional (non-distributed) applications.

Weaker read operations return values of some type lower in the lattice (*weak IPA types*), reflecting their possible inconsistency.
At the bottom of the lattice, the weak IPA type `Inconsistent[T]` encapsulate a value with unknown consistency.
The only possible operation on `Inconsistent[T]` is to *endorse* it.
Endorsement is an upcast, invoked by `Consistent(x)`, to the top element `Consistent[T]` from other types in the lattice:

~ Math
\inferrule{\gamma \vdash e_1 : \tau[T] \\ T \prec \tau[T]}{\gamma \vdash \operatorname{Consistent}(e_1) : T}
~

While `Inconsistent[T]` has value as a reminder to developers about consistency,
the key productivity benefit of the IPA type system is in the other weak IPA types.
Each of the consistency policies in [#policies] has a corresponding weak IPA type for operations performed under that policy.

#### Rushed types

The weak IPA type `Rushed[T]` is the result of read operations performed on an ADT with consistency policy `LatencyBound(x ms)`.
`Rushed[T]` is a *sum type*, with one variant per consistency level available to the implementation of `LatencyBound`.
Each variant is itself an IPA type (though the variants obviously cannot be `Rushed[T]` itself).
The effect is that values returned by a latency-bound object carry with them their actual consistency level.
A result of type `Rushed[T]` therefore requires the developer to consider the possible consistency levels of the value.

For example, a system with geo-distributed replicas may only be able to satisfy a read latency bound of 50 ms using a local quorum.
In this system, the `Rushed[T]` type would be the sum of three types `Consistent[T]`, `LocalQuorum[T]`, and `Inconsistent[T]`.
A match statement destructures the result of a latency-bound read operation:

```
set.size() match {
  case Consistent(x) => print(x)
  case LocalQuorum(x) => print(x + ", locally")
  case Inconsistent(_) => print("unknown")
}
```

The application may want to react differently to a local quorum as opposed to a strongly or weakly consistent value.
Note that because of the subtyping relation on IPA types, omitted cases can be matched by any type lower in the lattice [todo: James double-check this], ultimately falling back to `Inconsistent(_)`, 
so other cases need only be added if the application should respond differently to them. This allows applications to be portable between systems supporting different forms of consistency (of which there are many).

#### Interval types

The weak IPA type `Interval[T]` is the result of operations performed on an ADT with consistency policy `ErrorTolerance(x%)`.
`Interval[T]` represents an interval of numbers within which the true (strongly consistent) result lies.
The interval reflects uncertainty in the true value created by relaxed consistency, in the same style as work on approximate computing [@Bornholt:14:UncertainT].

The key invariant of the `Interval[T]` type is that operations within the interval are linearizable.
In other words, [todo: Brandon has a nice example of this]

#### Lower bounds

Weak IPA types enforce consistency safety by ensuring developers address the worst case results of weak consistency.
However, the weak IPA types are *lower bounds* on weakness:
one valid implementation of a system using IPA types is to always return strongly consistency values.
Moreover, the runtime guarantees that if every value returned has strong consistency, then the execution is linearizable, as if the system were strongly consistent from the outset.

~~ Notes
- High-level goals
	- Explicit performance bounds (latency)
	- Explicit approximation bounds (error tolerance)
	- Results in IPA types which express the resulting uncertainty
- ADTs
	- can't just express these on the *read* side, most require knowing how the *write* was done
	- e.g. `Consistency = Read.Consistency + Write.Consistency`, so `Write.ALL + Read.ONE = Strong`, or `Write.QUORUM + Read.QUORUM = Strong`
	- Other benefits of annotating ADTs:
		- portable / reusable
		- modular
	- Similar to Indigo's ([@Balegas:15:Indigo]) invariants, but expressing performance and approximation bounds
- Types of annotation
	- "static" bounds like `Consistency(Strong)` that fix a policy upfront
	- "dynamic" bounds like `LatencyBound(50 ms)` that choose a policy at invocation time
	- per-method bounds for ADTs (e.g. `Set[ID]` has `size` and `contains?` methods that could have different bounds)
- **Bounds**
	- `Set[ID] with Consistency(Strong)`
	- `Set[ID] with LatencyBound(50 ms) -> contains(ID): Rushed[Boolean]`
	- `Counter with ErrorTolerance(5%) -> read(): Interval[Long]`
- IPA type lattice
	- Inconsistent ($\bot$)
	- `Rushed | Interval | Leased` 
	- Consistent ($\top$)
- Rushed
	- Consistency level achieved
	- Consistency levels are themselves ordered (lattice something something), so one could imagine writing an application with fewer type bounds than are supported by the underlying system, and it would simply fall back to the strongest lower bound or whatever.
		- Example: write an app only handling "Strong" and "Weak": if the system supports intermediate levels that's fine, but the program will see all of them as "weak"
		- Not 100% sure how to describe this
- Interval
	- min, max, contains?, etc
	- linearizable within the error bound -- as long as we stay within the bound, everything is strongly consistent
- Leased goes away
- Semantics of mixed consistency levels?
	- If every operation comes back strong, it's just like strong consistency was chosen in advance -- so everything is linearizable
- Futures
	- (talk about how everything is implemented with futures, or just elide that?)
- All writes are statically at a certain consistency level
	- Why? So we don't have to reason about interactions with reads (would need flow analysis)
~~
