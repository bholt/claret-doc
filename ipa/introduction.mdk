# Introduction
<!--
~~ Notes
- obviously applications would like to ensure correctness,

- however they are often forced to relax correctness either for
  availability or to handle unexpected spikes in performance

- ideally applications would like to relax correctness in a way that
  still maintains the correctness of the application (i.e., return a
  value within 5%) or constrains the relaxation to when it is necessary
  (when there is a spike).

- further we would like to ensure that the relaxed correctness does
  not propagate to corrupt other data

- Unfortunately, with existing systems, applications approach
  inconsistency in an undisiplined way. Left alone, the application
  can corrupt all data in the system, making it useless to provide
  stronger consistency at any time.

* we introduce a more displined approach to inconsistency.
~~
-->

To provide good user experiences, modern datacenter applications and
web services must balance many competing requirements.  Programmers
need to preserve application correctness (e.g., never double-charging
for a purchase, or showing up-to-date results and accurate counts),
while minimizing response times to meet contractual service level
agreements (SLAs) or to keep user engagement high (e.g., Microsoft,
Amazon and Google all note that every millisecond of latency
translates to a loss in traffic and revenue
[@linden06:amazon;@forrest09:slow]).  Worse, programmers must maintain
this balance in an unpredictable environment where a black and blue
dress [@buzzfeed-dress] or Justin Bieber [@bieber-instagram] can
significantly change application performance in the blink of an eye.

Recognizing this trade-off, many existing storage systems support
configureable consistency levels; some allow programmers to set the
consistency of the entire store or each operation, while other provide
adaptable consistency SLAs.  Ideally, programmers would weaken
consistency guarantees only when it is necessary (e.g., a spike in
traffic or datacenter failure) to meet availability requirements, or
when it does not impact the application's correctness guarantees
(e.g., returning a slightly stale or estimated result is acceptable).
Unfortunately, if programmers are *undisciplined* in their use of
weakly consistent data (i.e., writing back to storage based on
inconsistent reads), they can easily corrupt application data,
lowering the consistency of the storage system to that of the weakest
read or write operation.

In this paper, we propose a more disciplined approach to consistency:
the *inconsistent, performance-bound, approximate (IPA)* programming
model for distributed storage systems. The IPA model provides a type
system for which type safety implies *consistency safety*: values from
weakly consistent operations cannot flow into stronger consistency
operations without explicit endorsement. More specifically, the IPA
type system provides the following features:

* *Abstract Data Types* (ADTs), supported by the storage system, that
  programmers can annotate with performance targets, which allow the
  storage system to automatically adapt to meet when conditions
  change, and consistency requirements, which allow programmers to
  express where preciseness is not required (e.g., the application
  plans to display an approximate count).

* *IPA types*, returned from the storage system, that express the
  consistency and correctness of potentially inconsistent values, and
  subtyping to allow applications to make decisions based on the
  actual consistency of data.

* *Type checking* that enforces the disciplined use of IPA types by
   requiring programmers to explicitly endorse the propagation of
   inconsistent values to strongly consistent ADTs.

We explore the IPA model by implementing two important distributed
runtime mechanisms: latency-bound operations, and a novel *error
tolerance* reservation system. We describe how these mechanisms can be
implemented in Scala for a distributed environment based on Cassandra,
and explain how the IPA programming model allows the system to trade
off performance and consistency, safe in the knowledge that the type
system has checked the program for consistency safety. We demonstrate
experimentally that these mechanisms allow applications to dynamically
adapt correctness and performance to changing conditions with a
counter microbenchmark and two applications: a simple Twitter clone
based on Retwis [@retwis] and a Ticket sales service modeled after
FusionTicket [@FusionTicket]. Our results show that IPA applications
adapt to changing execution environments while respecting
application-level correctness requirements.
