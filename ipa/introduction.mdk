# Introduction
<!--
~~ Notes
- obviously applications would like to ensure correctness,

- however they are often forced to relax correctness either for
  availability or to handle unexpected spikes in performance

- ideally applications would like to relax correctness in a way that
  still maintains the correctness of the application (i.e., return a
  value within 5%) or constrains the relaxation to when it is necessary
  (when there is a spike).

- further we would like to ensure that the relaxed correctness does
  not propagate to corrupt other data

- Unfortunately, with existing systems, applications approach
  inconsistency in an undisciplined way. Left alone, the application
  can corrupt all data in the system, making it useless to provide
  stronger consistency at any time.

- we introduce a more disciplined approach to inconsistency.

- Contributions
	- Consistency Safety
		- this is novel
		- motivate?
	- ADT-based Consistency Model
		- ADT provides semantics
		- Can define Pileus-style SLAs
		- Allows us to define value- or semantics-based metrics like Error Tolerance
~~
-->

To provide good user experiences, modern datacenter applications and
web services must balance many competing requirements.  Programmers
need to preserve application correctness while minimizing response
times; e.g., a web store must not double-charge for purchases and not
keeping users waiting too long (e.g., Microsoft, Amazon and Google all
note that every millisecond of latency translates to a loss in traffic
and revenue [@linden06:amazon;@forrest09:slow]).  Worse, programmers
must maintain this balance in an unpredictable environment where a
black and blue dress [@buzzfeed-dress] or Justin Bieber
[@bieber-instagram] can change application performance in the blink of
an eye.

Recognizing this trade-off, many existing storage systems support
configureable consistency levels; some allow programmers to set the
consistency of the entire store or each operation
[@cassandra;@riak;@Li:12:RedBlue;@Sovran:11:Walter].  Ideally,
programs would only weaken consistency guarantees when necessary to
meet availability requirements (e.g., during a spike in traffic or
datacenter failure), or when it does not impact the application's
correctness guarantees (e.g., returning a slightly stale or estimated
result is acceptable). Some storage systems support this type of
adaptable consistency [@Terry:13:SLAs;@Stribling:09:WheelFS].
Unfortunately, if programmers are *undisciplined* in their use of data
from weakly consistent operations, they can corrupt strongly
consistent stored data, lowering the consistency of the storage system
to that of the weakest read or write operation.

In this paper, we propose a more disciplined approach to consistency:
the *inconsistent, performance-bound, approximate (IPA)* storage
system. IPA's programming model provides a type system for which type
safety implies *consistency safety:* values from weakly consistent
operations cannot flow into stronger consistency operations without
explicit endorsement. IPA provides the following:

* *Error SLAs.* IPA is a data structure store, like Redis [@redis] or
   Riak [@riak], allowing it to provide both traditional performance
   bounds and novel error bounds (e.g., the programmer can bound the
   returned value to within 5\% of the correct value). Within these
   bounds, IPA automatically adapts to provide the strongest
   consistency possible under the current system load.

* *IPA consistency types.* IPA defines the consistency and correctness
   of every returned value using a new type system that allows
   programmers to reason about their use of data at different
   consistency levels and make decisions based on the actual
   consistency of returned values.

* *Consistency safety.* IPA enforces the disciplined use of IPA
   consistency types by requiring programmers to handle all potential
   consistency cases, or explicitly endorse the propagation of
   inconsistent values.

We implement an IPA prototype based on Scala and Cassandra and show
that IPA allows the programmer to trade off performance and
consistency, safe in the knowledge that the type system has checked
the program for consistency safety. We demonstrate experimentally that
these mechanisms allow applications to dynamically adapt correctness
and performance to changing conditions with three applications: a
simple counter, a Twitter clone based on Retwis [@retwis] and a Ticket
sales service modeled after FusionTicket [@FusionTicket]. 
