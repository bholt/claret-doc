# Evaluation
[todo: explain how we simulate network conditions using `tc netem` and `docker` üê≥]

~ Tab { #tab-conditions caption="Simulated network conditions" }
| Condition label   | Latencies (milliseconds)                 |
|:------------------|:-----------------------------------------|
| Local             | <1, <1, <1                               |
| Uniform/High load | 5, 5, 5                                  |
| Slow replica      | 10, 10, 100                              |
| Google            | 1&plusmn;.3, 110&plusmn;5, 160&plusmn;5  |
| Amazon            | 1&plusmn;.3, 80&plusmn;10, 200&plusmn;50 |
|-------------------|------------------------------------------|
~

## Counter microbenchmark
~~ Notes
- Latency bound
	- show how it can meet various latency bounds, compared with Strong and Weak
	- show that 95th percentile still meets latency bound!
	- show how many achieved stronger consistency, and how that correlates with actual consistency violations
- Reservations
	- show link between tighter bounds and lower performance
	- tie performance to the number of strong reads/reservation refreshes we had to do
	- show how interval width gets smaller with fewer writes
~~

~ Fig { #plot-counter caption="Counter benchmark: mean latency for a random mix of counter ops (20% increment, 80% read), with various IPA bounds, under various conditions." }
![](plots/rawmix_counter.pdf){ .onecol }
~

We start by measuring the performance of a very simple application that randomly increments and reads from a number of counters with different IPA bounds. [#plot-counter] shows the average latency of a 20% increment, 80% read workload over 200 counters randomly selected using a zipfian distribution.

### Latency bounds

~ Fig { #plot-counter-lbound caption="Consistency of latency-bound operations. Strong consistency is rarely possible within 10ms. With one slow replica, most reads can still achieve strong consistency, but with high network latencies or heavy load, it degrades to use weak consistency." }
![](plots/counter_lbound.pdf){ .onecol }
~

~ Fig { #plot-counter-lbound-tail caption="Latency bounds reduce unpredictable tail latency." }
![](plots/counter_lbound_tail.pdf){ .onecol }
~

Latency bounds aim to provide predictable performance for clients while attempting to maximize consistency. Under favorable conditions, when latencies and load are low, it is often possible to achieve strong consistency. Figure [#plot-counter] shows the average latency of 


## Applications
### Shopping Cart
[todo: demonstrate loading cart with a latency bound, but not allowing users to check out without doing a strong read]

### TicketSleuth
~~ Notes
- Modeled after FusionTicket (benchmark in [@Xie:14:Salt;@Xie:15:ACIDAlt])
- Demonstrates
~~

~ Fig { #plot-tickets caption="Ticket-sales app: mean latency of `purchase` action under various conditions. The `BoundedCounter` underlying ticket sales is safe even when weakly consistent, but latency bounds allow users to see strong consistency [todo:??]% of the time, while reservations bound error to less than 5% with similar performance." }
![](plots/tickets.pdf){ .onecol }
~

[todo: ticket sales app demonstrating hard lower bounds on counters]

### Twitter clone
[todo: demonstrating error tolerance for Counter (number of retweets), and latency bound for loading the timeline]
