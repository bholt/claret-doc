# Evaluation
[todo: explain how we simulate network conditions using `tc netem` and `docker` üê≥]

~ Tab { #tab-conditions caption="Simulated network conditions" }
| Condition label   | Latencies (ms)              |||
|:------------------|:-------:|:-------:|:----------|
| Local             | <1      | <1      | <1        |
| Uniform/High load | 5       | 5       | 5         |
| Slow replica      | 10      | 10      | 100       |
| Google            | 1 ¬± 0.3 | 110 ¬± 5 | 160 ¬± 5   |
| Amazon            | 1 ¬± 0.3 | 80 ¬± 10 | 200 ¬± 50  |
|-------------------|---------|---------|-----------|
~

## Counter microbenchmark
~~ Notes
- Latency bound
	- show how it can meet various latency bounds, compared with Strong and Weak
	- show that 95th percentile still meets latency bound!
	- show how many achieved stronger consistency, and how that correlates with actual consistency violations
- Reservations
	- show link between tighter bounds and lower performance
	- tie performance to the number of strong reads/reservation refreshes we had to do
	- show how interval width gets smaller with fewer writes
~~

~ Fig { #plot-counter caption="Counter benchmark: mean latency for a random mix of counter ops (20% increment, 80% read), with various IPA bounds, under various conditions." }
![](plots/rawmix_counter.pdf){ .onecol }
~

We start by measuring the performance of a very simple application that randomly increments and reads from a number of counters with different IPA bounds. [#plot-counter] shows the average latency of a 20% increment, 80% read workload over 200 counters randomly selected using a zipfian distribution.

### Latency bounds

~ Fig { #plot-counter-lbound caption="Consistency of latency-bound operations. Strong consistency is rarely possible within 10ms. With one slow replica, most reads can still achieve strong consistency, but with high network latencies or heavy load, it degrades to use weak consistency." }
![](plots/counter_lbound.pdf){ .onecol }
~

~ Fig { #plot-counter-lbound-tail caption="Latency bounds reduce unpredictable tail latency." }
![](plots/counter_lbound_tail.pdf){ .onecol }
~

Latency bounds aim to provide predictable performance for clients while attempting to maximize consistency. Under favorable conditions, when latencies and load are low, it is often possible to achieve strong consistency. Figure [#plot-counter] shows the average latency of 

### Error bounds
We use the reservation system described in [#reservations] to enforce error bounds. Though error bounds represent a relaxation from a strict strongly consistent read, they still have 
Our goal is to explore how expensive it is in practice to enforce these error bounds, and in particular to determine if reasonable error bounds that programs could rely on are achievable with performance comparable to weak consistency.

The general intuition behind reservations is to move synchronization off the critical path: by distributing write permissions among replicas, clients can get strong guarantees while only communicating with a single replica. This shifts the majority of the synchronization burden off of reads, which are typically more common. However, this balance must be carefully considered when evaluating the performance of reservations, more so than the other techniques.

[#plot-counter] contains results for error bounds ranging from 0% to 10%, showing the average latency of both reads and increments for a mix with 20% increments. We can see that how narrow the bounds are does affect performance, but in most cases, the latency of 5-10% error bounds have roughly the same performance as weak consistency.

[todo: plot of actual error with weak consistency compared to bounded error]

~ Tab { #tab-intervals caption="Reservations adapt to varying write loads, resulting in narrower intervals (tighter error bounds) than clients requested. [todo: add more mixes, gen line plot with %reads on x axis]" }
| Error Bound | 80% read | 99% read |
|:-----------:|:--------:|:--------:|
|  0% | 0    | 0    |
|  1% | 5.4  | 0.03 |
|  5% | 45.7 | 1.36 |
| 10% | 98.2 | 3.5  |
|-----|------|------|
~

## Applications
### Shopping Cart
[todo: demonstrate loading cart with a latency bound, but not allowing users to check out without doing a strong read]

### TicketSleuth
~~ Notes
- Modeled after FusionTicket (benchmark in [@Xie:14:Salt;@Xie:15:ACIDAlt])
- Demonstrates
~~

~ Fig { #plot-tickets caption="Ticket-sales app: mean latency of `purchase` action under various conditions. The `BoundedCounter` underlying ticket sales is safe even when weakly consistent, but latency bounds allow users to see strong consistency [todo:??]% of the time, while reservations bound error to less than 5% with similar performance." }
![](plots/tickets.pdf){ .onecol }
~

[todo: ticket sales app demonstrating hard lower bounds on counters]

### Twitter clone
[todo: demonstrating error tolerance for Counter (number of retweets), and latency bound for loading the timeline]
