# Introduction {#intro}

Techniques like caching and replication allow read-heavy workloads such as browsing static web pages or serving media-rich content to scale well under massive client loads. However, the steady increase in interactive applications like social networks results in more mixed workloads with writes causing significant conflicts [todo: cite]. Even content consumption can result in writes as providers track user behavior in order to personalize their experience, target ads, or collect statistics [@summingbird]. In addition, real-world systems also typically exhibit highly skewed access patterns (for example: *viral* meme propagation), leading to particularly high contention on some hot data items.

These challenging scenarios are where the bulk of engineering effort goes when scaling up services, to avoid catastrophic failures and mitigate poor tail behavior. The core problem with these write conflicts is synchronizing to enforce the ordering constraints necessary to provide strong consistency. Therefore, a typical solution is to relax consistency, permitting writes to go to any replica, distributing the load and reducing conflicts, at the cost of a more challenging-to-use programming model.

However, there is a different way to reduce conflicts: leveraging higher-level application semantics to expose more concurrency, eliminating false conflicts and ordering constraints. Databases and distributed systems have long used properties such as commutativity to reduce coordination and synchronization. The challenge is always in exposing these properties in applications, by restricting to relational models [todo: cite] or monotonic operations [@BloomL], or by explicit annotations [todo: cite].

As an alternative, in this work we propose using *abstract data types* (ADTs) to express high-level application semantics to datastores. ADTs hide their representation, allowing users and systems alike to reason about their logical behavior, including algebraic properties like commutativity. Datastores can leverage these properties to avoid conflicts without changing the behavior users observe. Users benefit from the flexibility and expressivity, either reusing data structures from a common library or extending it with custom ADTs to match their specific application. Our prototype ADT-store, *Claret*, implements optimizations such as transaction boosting, operation combining, and phasing, to allow even highly contentious write-heavy workloads to perform well. [todo: repeating ourselves here? just save this for the *contributions*?]

Datastores supporting complex datatypes and operations are already popular. Many datastores support simple collections such as *lists*, *sets*, and *maps*, and some, such as Cassandra and Voldemort, support custom data types as blackboxes. Redis [@redis], currently the most popular key-value store, supports a much larger, though fixed, set of complex data types and a number of operations specific to each type. Currently, these datastores treat data types as just blackboxes with special update functions. In *Claret*, we expose the logical properties of these data types to the system and use them to improve synchronization and concurrency control to enable performant strong distributed transactions.

This work makes the following contributions:

- Models of real-world high-contention scenarios in two modified benchmarks: Rubis (online auction), and Retwis (Twitter-like social network).
- Design of an *extensible ADT-store*, Claret, with interfaces to express logical properties of new ADTs.
- Implementation of *transaction boosting*, *operation combining*, and *phasing* optimizations which leverage ADT properties.
- Evaluation of the impact of these optimizations on raw transaction performance and benchmarks modeling real-world contention.

In the remainder of this paper we will describe the design of the system and evaluate the impact using ADTs has on performance. But first, we must delve more deeply into what makes real-world workloads particularly difficult.
