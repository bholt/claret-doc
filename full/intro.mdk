# Introduction {#intro}

Reading is easy. Reads don't invalidate other reads, so they can all happen concurrently, making them loved by all in distributed systems. Truly read-only workloads, such as browsing static pages or viewing media-rich content, are relatively easy to scale using geo-replication and caching. Writes, on the other hand, may conflict.
The steady increase in interactive applications like social networks has resulted in more mixed workloads with writes causing significant conflicts. Even content consumption causes writes as providers track user behavior in order to personalize their experience, target ads, or collect statistics [@summingbird].

However, it is write *contention* which makes scaling so difficult because real-world systems tend to exhibit highly skewed access patterns. Today's online ecosystem is dominated by viral memes propagating through social networks, blogs, and news sites, causing one page, post, or tweet to be suddenly inundated with load, crashing systems that are unprepared.
When Ellen Degeneres posted a selfie at the Oscars in 2014, it was retweeted so much and so quickly that Twitter briefly slowed to a standstill [@ellenselfie].

These challenging scenarios are where the bulk of engineering effort goes when scaling online services, to avoid catastrophic failures and mitigate poor tail behavior. The core problem with write conflicts is synchronizing to enforce the ordering constraints necessary to provide strong consistency. Luckily, many of these orderings are actually irrelevant: at the application level, the actions are okay to reorder. For example, it is not necessary to keep track of the order in which people retweeted Ellen's selfie.

Eventual consistency is one way to avoid unnecessary constraints, but applications have to deal with inconsistent data, especially during times of high contention. However, if systems could directly use these application-level constraints to expose concurrency and avoid over-synchronizing, they could eliminate false conflicts and avoid falling over during writing spikes, without giving up correctness. Databases and distributed systems have long used properties such as commutativity to reduce coordination and synchronization. The challenge is always in communicating these application-level properties to the system.

In this work, we propose a new way to express high-level application semantics: through *abstract data types* (ADTs). ADTs allow users and systems alike to reason about their logical behavior, including algebraic properties like commutativity, rather than the low-level operations used to implement them. Datastores can leverage this higher-level knowledge to avoid conflicts without changing the behavior users observe. Users benefit from the flexibility and expressivity, reusing data structures from a common library or extending it with custom ADTs to match their specific application. Our prototype ADT-store, *Claret*, demonstrates how ADT awareness can be added to a common datacenter model.

Datastores supporting complex datatypes and operations are already popular. Many datastores support simple collections such as *lists*, *sets*, and *maps*, and some, such as Cassandra [@cassandra] and Voldemort [@voldemort], support custom data types as blackboxes. Redis [@redis], one of the most popular key/value stores, supports a large, fixed set of complex data types and a number of operations specific to each type. Currently, these datastores treat data types as just blackboxes with special update functions. In *Claret*, we expose the logical properties of these data types to the system and use them to improve synchronization and concurrency control to enable performant strong distributed transactions.

This work makes the following contributions:

- Models of real-world high-contention scenarios in two modified benchmarks: Rubis (online auction), and Retwis (Twitter-like social network).
- Design of an *extensible ADT-store*, Claret, with interfaces to express logical properties of new ADTs.
- Implementation of *transaction boosting*, *operation combining*, and *phasing* optimizations which leverage ADT properties.
- Evaluation of the impact of these optimizations on raw transaction performance and benchmarks modeling real-world contention.

In the remainder of this paper we will describe the design of the system and evaluate the impact ADT-enabled optimizations have on transaction performance. But first, we must delve more deeply into what causes contention in real applications.
