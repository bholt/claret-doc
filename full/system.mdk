# System model

~ Fig { #system-diagram caption="*System model:* End-user requests are handled by replicated stateless application servers which all share a sharded datastore. Claret operates between these two layers, extending the datastore with ADT-aware concurrency control (*Claret server*) and adding functionality to the app servers to perform ADT operations and coordinate transactions (*Claret client*)." }
![Claret System Diagram](fig/system-diagram.pdf){.onecol}
~

The concept of ADTs could be applied to many different datastores and systems. For Claret, we focus on one commonly employed system architecture: a sharded datastore shared by many stateless replicated application servers within a single datacenter.
For horizontal scalability, datastores are typically divided into many shards, each containing a subset of the key space (often using consistent hashing), running on different hosts (nodes or cores).
Frontend servers implement the core application logic and expose it via an API to end users which might be mobile clients or web servers. These servers are replicated to mitigate failures, but each instance may handle many concurrent end-user connections, mediating access to the backing datastore where application state resides.

Claret operates between these frontend servers and the datastore. 
Applications model their state using ADTs and the operations they provide; this application logic is implemented on the clients which in this case are the frontend servers.
Clients are responsible for coordinating their transactions, retrying if necessary.
A new, ADT-aware concurrency control system is added to each shard of the core datastore.
ADT optimizations occur both in the concurrency control system and in the client as it issues operations and prepares transactions.

## Programming model

~ Fig { #fig-adt-bid caption="Claret programming model example showing the ADT for a scored set and how it can be used to implement the Bid transaction from [#fig-levels]." }
![Example ADT version of Bid transaction](fig/adt-bid.pdf){.onecol}
~

The Claret programming model is not significantly different than traditional key/value stores, especially for users of Redis [@redis]. Rather than just strings with two available operations, `put` and `get`, records can have any of a number of different types, each of which have operations associated with them.
Each record has a type, determined by a tag associated with its key so invalid operations are prevented on the client.
The particular client bindings employed are not essential to this work; our code examples will use Python-like syntax similar to Redis's Python bindings though our actual implementation uses C++. An example of an ADT implementation of the Bid transaction is shown in [#fig-adt-bid].

## Consistency model

Rather than relying on weaker consistency models, Claret aims to use application semantics to make strong consistency practical. Instead of guarding actions in case of inconsistency, application programmers instead focus on exposing concurrency by choosing ADTs that best represent the desired behavior and expose concurrency.

Individual operations in Claret are strictly linearizable, committing atomically on the shard that owns the record. Each record, including aggregates, behaves as a single object living on one shard. Atomicity is determined by the granularity of individual ADT operations. Custom ADTs allow arbitrarily complex application logic to be performed atomically, provided they conceptually operate on a single "record". Composing actions between multiple objects requires transactions.

## Transactions

Claret implements serializable distributed transactions with strong isolation guarantees. [#fig-adt-bid] shows a possible client interface with `begin` and `commit`, though the retry logic is elided. Mutating operations are staged until the transaction commits to avoid rollbacks, so clients must be aware to not expect reads in the same transaction to observe those changes (similar to the behavior of Spanner [@Spanner]).

Note that there are no fundamental differences in programming model from Redis from the clients' view (with the exception of distributed transactions). All that is changed is that under the hood, Claret will be taking advantage of these ADTs in ways which we will describe next.
