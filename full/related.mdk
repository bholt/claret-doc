# Related Work

## ADTs in databases

There is significant historic work on introducing abstract data types into databases, to support custom indices [@Stonebraker:83;@Stonebraker:86]. The first algorithms for leveraging ADT semantics for concurrency control come from the mid 1980s, with Schwarz, Herlihy and Weihl [@Schwarz:84;@Weihl:1988;@Herlihy:88;@Fekete:90]. That work allowed databases to reason about the commutativity of operations within transactions using abstract locks, and allowed the database system to be extended with user-defined types that expressed their abstract behavior to the database. Another contemporary system [@Spector:85] used similar type-based locks with an early form of distributed transactions. However, since then, the concept has lost popularity. Claret revives these ideas and incorporates them into the modern world of key-value stores and web applications.

## Improving Transaction Concurrency

Several recent systems have explored ways of exposing more concurrency between transactions. An old technique, transaction chopping [@Shasha:95], statically analyzes transactions and breaks them into smaller pieces that reduces the scope where locks are held, but potentially resulting in cascading rollbacks. A more recent system, Lynx [@Zhang:SOSP13], extends this with additional checks for commutative operations and allows conflicting transactions to interleave safely by enforcing consistent ordering. Salt [@Xie:14] borrows the notion of chopping, but allows programmers to choose some transactions to execute using weaker consistency and isolation (termed *BASE* transactions). By focusing on "baseifying" only the highly contentious transactions, programmers can get most of the benefits of NoSQL systems while maintaining the strong ACID guarantees on the rest. 

Most recently, Callas [@Xie:15] introduced modular concurrency control which operates similarly to Salt but maintains ACID semantics for all transactions. Callas places transactions which may commute with each other into a separate group, which can use specialized concurrency control to execute them concurrently when it is safe to do so. Abstract locks, employed by Claret, cleanly expose concurrency among transactions, avoiding false conflicts from commuting operations, without needing to divide transactions into arbitrary groupings and without the complex multi-tiered locking strategy needed in Callas to manage inter-group dependencies. Other concurrency control techniques introduced by Callas, such as runtime pipelining are orthogonal and could usefully be applied in Claret.

## Commutativity

Commutativity is well known, especially in distributed systems, for enabling important optimizations. Though the original work leveraging commutativity was in relational database systems with highly sophisticated concurrency control, recently, there has been a resurgence of systems without a predefined data model, such as NoSQL databases and transactional memory, leveraging commutativity.

Several NoSQL systems specialize for commutative operations to improve performance of serializable distributed transactions. Lynx [@Zhang:SOSP13] statically splits transactions into chains, but allows users to annotate parts of transactions as commutative to improve performance.
Doppel [@Narula:OSDI14], a multicore in-memory database, allows commutative operations on highly contended records to be performed in parallel *phases* with a technique called *phase reconciliation*. In the context of distributed transactional memory, HyFlow [@Kim:EuroPar13] combines multi-versioning and commutativity to reorder commutative transactions before others. HyFlow effectively combines boosting and phase reconciliation, but only if entire transactions commute. Claret exposes commutativity as a natural part of the application design, and allows more nuanced commutativity to be exploited within transactions through abstract locks.

Commutativity has been used in eventually consistent datastores to improve convergence. RedBlue consistency [@Li:OSDI12] treats commutative (blue) and non-commutative (red) operations differently, exploiting the convergence guarantees of blue operations to avoid coordination. Conflict-free (or convergent) replicated data types (CRDTs/CvRDTs) [@Shapiro:SSS11] force operations to commute by defining merge functions that resolve conflicts automatically. Riak [@riak] has implemented CRDTs for production use cases. 
Claret's strictly linearizable model exposes concurrency without relaxing consistency because eventual consistency is notoriously difficult for programmers to reason about and CRDT behavior is often still counterintuitive.

Bloom and BloomL [@Bloom;@BloomL] apply the CALM theorem to help programmers design applications in ways that do not require distributed coordination by restricting them in certain ways that ensure monotonicity. This lets programmers avoid reasoning about inconsistency, but not all programs can easy be expressed in this way, whereas Claret can support any design, making the question of commutativity a performance issue only.


## Complex datatypes in NoSQL

There is a recent trend toward supporting complex data types in NoSQL datastores. At the forefront is Redis [@redis], one of the most popular key/value stores, which supports many data types and complex operations on them, exposed through a very wide but fixed set of commands, but does not support distributed transactions. Hyperdex [@hyperdex;@hyperdex-web] supports atomic operations on lists, sets, and maps, as well as JSON-style documents. Hyperdex's Warp transaction system [@hyperdex-warp] reasons dynamically about dependencies between transactions to avoid unnecessary conflicts, but does not consider operation commutativity. Many other popular datastores such as MongoDB [@mongodb] support atomically updating parts of JSON documents but do not leverage commutativity.

In these systems, data types are used primarily to provide programmers with a library of functionality they can reuse.
Claret leverages those same data structures to expose concurrency optimizations, and provides interfaces for programmers to extend it with custom types.
