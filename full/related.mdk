# Related Work

## Commutativity

Commutativity is well known, especially in distributed systems, for enabling important optimizations. Since the 80s, commutativity has been exploited by database systems designers [@Weihl:1988;@Fekete:90] within the safe confines of relational models, where complete control of the data structures allows systems to determine when transactions may conflict. Recently, commutativity has seen a resurgence in systems without a predefined data model, such as NoSQL databases and transactional memory.

Several NoSQL systems specialize for commutative operations to improve performance of serializable distributed transactions. Lynx [@Zhang:SOSP13] statically splits transactions into chains, but allows users to annotate parts of transactions as commutative to improve performance.
Doppel [@Narula:OSDI14], a multicore in-memory database, allows commutative operations on highly contended records to be performed in parallel *phases* with a technique called *phase reconciliation*. In the context of distributed transactional memory, HyFlow [@Kim:EuroPar13] combines multi-versioning and commutativity to reorder commutative transactions before others. HyFlow effectively combines boosting and phase reconciliation, but only if entire transactions commute. Claret exposes commutativity as a natural part of the application design, and allows more nuanced commutativity to be exploited within transactions through abstract locks.

Commutativity has been used in eventually consistent datastores to improve convergence. RedBlue consistency [@Li:OSDI12] treats commutative (blue) and non-commutative (red) operations differently, exploiting the convergence guarantees of blue operations to avoid coordination. Conflict-free (or convergent) replicated data types (CRDTs/CvRDTs) [@Shapiro:SSS11] force operations to commute by defining merge functions that resolve conflicts automatically. Riak [@riak] has implemented CRDTs for production use cases. However, these approaches still require programmers to reason about eventual consistency, and the behavior of CRDTs is often still counterintuitive. Bloom and BloomL [@Bloom;@BloomL] help programmers avoid reasoning about inconsistency by providing tools to design applications that are automatically monotonic and do not require coordination.

## Data structure stores

There is a recent trend toward supporting complex data types in NoSQL datastores. At the forefront is Redis [@redis], one of the most popular key/value stores, which supports many data types and complex operations on them, exposed through a very wide but fixed set of commands, but does not support distributed transactions. Hyperdex [@hyperdex;@hyperdex-web] supports atomic operations on lists, sets, and maps, as well as JSON-style documents. Hyperdex's Warp transaction system [@hyperdex-warp] reasons dynamically about dependencies between transactions to avoid unnecessary conflicts, but does not consider operation commutativity. Many other popular datastores such as MongoDB [@mongodb] support atomically updating parts of JSON documents, but do not leverage commutativity at all.

