# Trading off consistency for performance
In order to meet scalability, availability, and latency requirements, distributed systems programmers must routinely make trade-offs between consistency and performance [@Bailis:HAT;@Brewer:CAP;@Gilbert:CAP]. Continuing our recurring theme, the problem with consistency is not in the *average case*, but rather in the exceptional cases: those few *high contention* cases, and the *long tail* of disproportionately slow requests [@Dean:13:Tail].

Many solutions have been proposed that deal with various aspects of the problem. Even just choosing which one is right in a given scenario is a daunting task, so in this section I will attempt to organize and categorize the various benefits and costs of each technique. But first we must discuss what consistency is.

## Consistency models
Analogous to memory models in computer architecture, consistency models refer to the allowable reorderings of operations and their visibility in a distributed system. Differing from architecture memory models where strong coherence is assumed, consistency models frequently expose the existence of replicas to programmers. This makes them significantly more difficult to reason about, as if memory models were not complex enough.
<!-- Consistency models can be loosely organized along an axis of increasing ordering guarantees. -->

The strongest consistency model, *strict serializability* (Lamport's *sequential consistency* [@Lamport:79:SC] combined with Herlihy's *linearizability* [@Herlihy:90:Linear]) guarantees that operations appear to occur in a global serial order that all observers agree on and that corresponds to real time. This, and any form of consistency that requires enforcing a *global total order* is theoretically impossible to enforce with *high availability* due to the possibility of network partitions (this is the essence of the CAP theorem [@Brewer:CAP;@Gilbert:CAP]). In practice, strict serializability may not be wholly impractical for the average case, but ensuring it in *all* cases is prohibitively expensive.

At the other extreme, *eventual consistency*, the least common denominator among consistency models, simply guarantees that if update operations stop occurring, all replicas will eventually reflect the same state [@Vogels:EC]. Under this model, programmers cannot count on subsequent operations reflecting the same state, because those operations could go to any replica at any time, and those replicas are continuously receiving updates from other nodes.

There are a whole family of models similar to eventual consistency which add various ordering constraints:

- *Monotonic writes* ensure that writes from a client are serialized.
- *Monotonic reads* ensures that reads will not observe earlier values than have been seen by a particular client already
- *Read-your-writes* ensures that a client will at least observe its own effects
- *Causal consistency* ensures that operations from different clients causally following a write will observe that write (by some definition of *causation* which the system must track)

There are too many variations on these and other models to enumerate, including combinations of them. Each restricts the possible reorderings, making some cases easier for programmers to reason about, while also reducing the flexibility of the system and reducing performance. For instance, many require *sticky sessions* [@Terry:94:Session], which forces clients to continue communicating with a particular replica, even if it is not the fastest, or lowest latency, or most up-to-date one available.

As a way of trading off consistency for performance, weak consistency models are a poor choice. A particular consistency model must often be chosen at a very coarse grain, possibly at the level of an entire database's configuration. Applications can enforce stronger guarantees on top of a weaker model with various consensus protocols, but these must be chosen and implemented carefully, and the extra code written to handle this is not easily adapted to changes in the underlying consistency model.
In general, weak consistency models are not modular: adding or changing an operation in one place may require changing assumptions about ordering elsewhere. Visibility constraints require considering all pairs of interacting operations to determine which orders are allowable.

##  Bounded staleness
In theory, eventually consistent systems provide absolutely no guarantees during execution because there is no bound on the time it must take for updates to propagate, and there are almost no situations where updates are guaranteed not to occur. In practice, however, programmers typically observe very few actual consistency errors, even at large scale [@Lu:15:Facebook]. This is because the propagation time, or *inconsistency window* is typically very small, on the order of tens of milliseconds [@Bailis:12:PBS], so few accesses observe the gap. However, programmers cannot rely on these observations because they do not hold in all cases. High contention situations are particularly problematic because with more concurrent updates and accesses, the chances of observing inconsistencies is much higher, and the value is also likely to be further from the correct value.

In order to help programmers reason about staleness, Bailis et al. [@Bailis:12:PBS] introduced a metric called *probabilistically bounded staleness* (PBS) which quantifies the staleness of accesses, either in terms of *time* or *versions*. By observing the distributions of propagation delays, round trip times, and rate of updates, their implementation builds a model of the system and uses it to predict staleness during execution.

## CRDTs
...

## Consistency-based SLAs
[todo: figure showing an example SLA]

With *consistency based SLAs* [@Terry:13:SLAs], programmers can explicitly trade off consistency for latency. A consistency SLA specifies a target latency and a consistency level (e.g. 100 ms with read-my-writes). In this programming model, operations specify a set of desired SLAs, each associated with a *utility*. Using a prediction mechanism similar to PBS, the Pileus system attempts to determine which SLA to target to maximize utility, typically to achieve the best consistency possible within a certain latency.

Allowing users to specify their desired latencies and consistencies directly to the system could be extremely powerful and freeing. However, because it is so fine-grained, the burden of choosing target latencies and consistency for each operation could be quite high, and it seems difficult to compose a sequence of operations and SLAs to achieve an overall target latency or correctness criteria.

## Annotating constraints
[todo: figure showing annotations for both on bank account example]

Some recent work has explored ways of enforcing stronger ordering guarantees where necessary within the context of eventual consistency. Commonly used eventually consistent datastores support variable consistency levels, such as Cassandra [@cassandra] on a per-operation basis, and Riak [@riak] on user-defined namespaces. However, they leave programmers to determine where to use stronger consistency in order to achieve their correctness goals.

Quelea [@Sivaramakrishnan:15:Quelea] has programmers write *contracts* to describe ordering constraints between operations and then automatically selects the correct consistency level for each operation to satisfy all of the contracts. Contracts are specified in terms of low-level consistency properties such as *visibility* and *session order*.
For example, to ensure a non-negative bank account balance, a contract indicates that all `withdraw` operations must be visible to one another, forcing the operation to be executed with sequential consistency.
Because correctness properties are specified *independent of a particular consistency model*, or set of consistency levels, they are *composable* with each other and *portable* to other datastores supporting different consistency options. However, the low-level primitives used in contracts may not be intuitive for programmers and still require reasoning about all the possible anomalies between operations.

Indigo [@Balegas:15:Indigo] takes a different approach to expressing application requirements: instead of specifying visibility and ordering constraints, programmers write *invariants over abstract state and state transitions*, and annotate *post-conditions* on actions to express their side-effects in terms of the abstract state. They then perform a static analysis to determine where concurrent execution could violate the invariants and add coordination logic to avoid those conflicts. To revisit the bank account example, in Indigo, one would specify an invariant such as `forall x: balance(x) >= 0`, and then indicate that `withdraw(x, y)` decrements `balance(x)` by `y`.

Indigo's approach provides an excellent way to express application-level semantics and have the system automatically figure out how to enforce them. The primary downside is that abstract state must be modeled separately from the true application state. Additionally, though their invariants can specify hard constraints, they do not have a way to express the soft constraints we discussed in [#sec-requirements].

## Bloom
Instead of finding the places where coordination is necessary, the philosophy of Bloom [@Alvaro:11:Bloom;@Conway:12:BloomL] is to find ways to write programs that completely avoid the need for coordination. The *CALM* (Consistency And Logical Monotonicity) principle advocated by this work formalizes the requirements for a program to be eventually consistent, obviating the need for coordination. It is built around the notion of monotonicity, where programs compute sets of facts that grow over time so that information is never lost and convergence can be guaranteed.

In the Bloom model, programmers express applications as *statements* about monotonically growing sets of *facts*. These facts can be encoded as sets or other collections with suitable *merge functions* ensuring values of the type have a well-defined partial order [@Conway:12:BloomL]. Bloom statically ensures that programs compose these types in ways that are monotonic.

In it's pure form, Bloom's programming model can be quite restrictive, so later work on Blazes [@Alvaro:14:Blazes] showed how the monotonicity analysis could be used in conjunction with annotations on traditional distributed applications to determine where coordination is unnecessary. This style of programming is somewhat similar to the models from Indigo and Quelea in the previous section, though the annotations in Blazes are on streams. Bloom and its variants can ensure *eventual* consistency, but this says nothing about how long it will take or what intermediate states will be observable, so in practice, users would still have to worry about observing stale or inconsistent states.

## Models inspired by distributed version control {#sec-revisions}
One of the troubles with weakly consistent replication is that it is often not possible to construct a serializable history of an execution, which makes it very difficult to reason about which effects were visible to different clients at various points in time. Distributed version control systems (DVCS) like Git have inspired alternative ways of viewing concurrent execution. DVCSs allow individuals to work concurrently on *forks* or *branches* without interference and resolve conflicts at explicit *merge* points later. These histories are not serializable, but they still allow users to easily understand when effects become visible to different observers.

The *push/pull model of transactions* formalized several consistency and transaction models in these terms inspired by DVCS. A model called *branch consistency* proposed for a system called TaRDIS [@Crooks:15:Tardis] uses the notion of branching and merging for isolation and conflict resolution in geo-replicated systems, delegating conflict resolution to applications.

*Concurrent revisions* [@Burckhardt:10:Revisions] proposes an execution model built around forking and joining state along with concurrent execution to make sharing explicit.
In this model, concurrent tasks *fork* a copy of the state they access. Changes to forked state are only visible to that task and its descendants until the concurrent task is *joined* back in. On join, changes to forked data items are *merged* according to their type. For example, as a cumulative type, a forked `Counter` tracks increments made to it, and when *joined*, adds those increments to the original value. In this way, multiple concurrent tasks can increment the shared `Counter` without conflicting and it is clear exactly when their effects are made visible. Follow-on work extended the ideas of concurrent revisions and revision diagrams to reason about eventual consistency: in eventually consistent transactions [@Burckhardt:12:ECTxn] and  mobile/cloud applications [@Burckhardt:12:Cloud].

These programming models show that there is hope for reasoning about weakly consistent replicated data. The *isolation types* and *cloud types* from concurrent revisions provide useful semantics for working with highly contended data. In these models, trading off consistency for performance is not as clear-cut; *revision diagrams* and DVCS histories imply strict coordination points. It is also unclear how to enforce global constraints on forked data. Consider again the ticket sales example: in order to ensure tickets are not over-sold, concurrent forks must somehow know how many of the remaining tickets they are allowed to sell, without knowing how many other forks exist, breaking the abstraction.

## Transactions

Transactions are a well-established way to provide stronger guarantees among some operations. By choosing the type and granularity of transactions, programmers have some control over the correctness and performance of their applications. Like strict serializability, full ACID transactions require a global order so are prohibitive to scaling and high availability. As the antithesis of the strong guarantees of ACID, some have termed the weaker semantics of eventual consistency *"BASE"* (Basically Available, Soft state, Eventually Consistent) [@Pritchett:08:BASE]. Luckily, programmers are no longer restricted to simply choosing between these two extremes; some have proposed ways to bridge the gap.

### Salt: Combining ACID and BASE

Just as a small fraction of data items are responsible for the majority of contention, the same is true for transactions. Rather than forcing programmers to give up ACID semantics for their entire application, Salt [@Xie:14:Salt] allows transactions with BASE semantics to coexist safely with ACID transactions. Using new locking schemes, they ensure that transactions executing with weaker BASE semantics cannot violate the strong safety guarantees of the ACID transactions.

Converting an ACID transaction to execute without those guarantees is an error-prone task; it involves considering all the new possible interleavings and establishing how to resolve all the possible conflicts without coordination. Salt's model means that programmers only need to "BASE-ify" the transactions causing performance or scaling problems. This makes it relatively straightforward to trade off consistency where necessary, but does not do much to help programmers deal with the weaker semantics.
