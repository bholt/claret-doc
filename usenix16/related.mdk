# Related Work

## ADTs in databases

ADT concepts were first used in databases to support custom indices [@Stonebraker:83;@Stonebraker:86]. The first algorithms for leveraging ADT semantics for concurrency control come from the mid 1980s, by Schwarz, Herlihy and Weihl [@Schwarz:84;@Weihl:1988;@Herlihy:88;@Fekete:90]. That work introduced abstract locks to allow databases to leverage commutativity and also allowed user-defined types that expressed their abstract behavior to the database. Another classic system [@Spector:85] used type-based locks in an early form of distributed transactions. However, modern NoSQL key/value stores, in an effort to improve scalability and flexibility, have simplified the interface so much that this information is lost. Claret shows how ADTs can be incorporated into these modern systems without sacrificing scalability or flexibility.

## Improving Transaction Concurrency

Several recent systems have explored ways of exposing more concurrency between transactions. An old technique, transaction chopping [@Shasha:95], statically analyzes transactions and breaks them into smaller pieces that reduces the scope where locks are held, but potentially resulting in cascading rollbacks. A more recent system, Lynx [@Zhang:SOSP13], extends this with additional checks for commutative operations and allows conflicting transactions to interleave safely by enforcing consistent ordering. Salt [@Xie:14] borrows the notion of chopping, but allows programmers to choose some transactions to execute using weaker consistency and isolation (termed *BASE* transactions). By focusing on "baseifying" only the highly contentious transactions, programmers can get most of the benefits of NoSQL systems while maintaining the strong ACID guarantees on the rest. 

Most recently, Callas [@Xie:15] introduced modular concurrency control which operates similarly to Salt but maintains ACID semantics for all transactions. Callas allows transactions that often conflict with one another to be placed into a group together and handled using specialized concurrency control, such as runtime pipelining. Boosting and phasing could both be applied within one of these groups to expose concurrency among frequently conflicting transaction types, along with runtime pipelining. It would be interesting to explore whether Claret's ADT knowledge could be used to inform Callas's grouping decisions, which are crucial to performance.

## Commutativity

Commutativity is well known, especially in distributed systems, for enabling important optimizations. Though the original work leveraging commutativity was in relational database systems with highly sophisticated concurrency control, recently, there has been a resurgence of systems without a predefined data model, such as NoSQL databases and transactional memory, leveraging commutativity.

Several NoSQL systems specialize for commutative operations to improve performance of serializable distributed transactions. Lynx [@Zhang:SOSP13] statically splits transactions into chains, but allows users to annotate parts of transactions as commutative to improve performance.
Doppel [@Narula:OSDI14], a multicore in-memory database, allows commutative operations on highly contended records to be performed in parallel *phases* with a technique called *phase reconciliation*. In the context of distributed transactional memory, HyFlow [@Kim:EuroPar13] combines multi-versioning and commutativity to reorder commutative transactions before others. HyFlow effectively combines boosting and phase reconciliation, but only if entire transactions commute. Claret exposes commutativity as a natural part of the application design, and allows more nuanced commutativity to be exploited within transactions through abstract locks.

Commutativity has been used in eventually consistent datastores to improve convergence. RedBlue consistency [@Li:OSDI12] treats commutative (blue) and non-commutative (red) operations differently, exploiting the convergence guarantees of blue operations to avoid coordination. Conflict-free (or convergent) replicated data types (CRDTs/CvRDTs) [@Shapiro:SSS11] force operations to commute by defining merge functions that resolve conflicts automatically. Riak [@riak] has implemented CRDTs for production use cases. 
Claret's strictly linearizable model exposes concurrency without relaxing consistency because CRDT behavior is often still counterintuitive.

Bloom and BloomL [@Bloom;@BloomL] help programmers design applications in ways that do not require distributed coordination by restricting them to ensure monotonicity. This lets programmers avoid reasoning about inconsistency, but not all programs can easy be expressed in this way, whereas Claret can support any design, making the question of commutativity a performance issue only.


## Complex datatypes in NoSQL

There is a recent trend toward supporting complex data types in NoSQL datastores. At the forefront is Redis [@redis], one of the most popular key/value stores, which supports many data types and complex operations on them, exposed through a very wide but fixed set of commands, but does not support distributed transactions. Hyperdex [@hyperdex;@hyperdex-web] supports atomic operations on lists, sets, and maps, as well as JSON-style documents. Hyperdex's Warp transaction system [@hyperdex-warp] reasons dynamically about dependencies between transactions to avoid unnecessary conflicts, but does not consider operation commutativity. Many other popular datastores such as MongoDB [@mongodb] support atomically updating parts of JSON documents but do not leverage commutativity.

In these systems, data types are used primarily to provide programmers with a library of functionality they can reuse.
Claret leverages those same data structures to expose concurrency optimizations, and provides interfaces for programmers to extend it with custom types.
